---
title: 
author: xinyu
date: 2024-04-10 09:36:10 +0800
categories: []
tags: []
---

## 在MATLAB创建循环进度条

事实上，MATLAB自带`waitbar`函数可以使用图窗显示进度条，可是当我们使用MATLAB提供的API调用其进行计算时，图窗并不能够显示（如使用VScode中的matlab插件），此时运行时间较长的程序则需要我们自己创建进度条以用于打印输出。

关于这一点，我们可以使用MATLAB中的结构体实现这一功能，使用示例为：
```matlab
% Example 
% Include forWaitbar.m
N = 1000;
mywaitbar = forWaitbar(N);
for i = 1:N
    pause(0.1);
    mywaitbar.show_bar;
end
```
其中所需要的`forWaitbar.m`文件定义如下。我们使用了一个结构体来实现这一功能。
```matlab
classdef forWaitbar < handle
    properties (Access = private)
        solid_square = '*'; % The symbol of completion
        hollow_square = '-'; % The symbol of waiting
        N; % 总循环数
        temp_num; % 当前循环数
        square_nums = 40; % 打印方块数
        threshold; % 打印阈值
        Count_p_num; % 打印计数器
        s_num; % 方块计数器1
        h_num; % 方块计数器2
    end

    methods
        function obj = forWaitbar(N)
        % 初始化
            obj.N = N;
            obj.temp_num = 0;
            obj.Count_p_num = 0;
            obj.s_num = 0;
            obj.h_num = obj.square_nums;
            obj.threshold = fix(N/obj.square_nums);
        end
        function show_bar(obj)
            obj.Count_p_num = obj.Count_p_num + 1;
            obj.temp_num = obj.temp_num + 1;
            if obj.Count_p_num >= obj.threshold || obj.temp_num == obj.N || obj.temp_num == 1
                if obj.s_num ~= obj.square_nums - 1 || obj.temp_num == obj.N
                    obj.Count_p_num = 0;
                    obj.s_num = obj.s_num + 1;
                    obj.h_num = obj.h_num - 1;
                    obj.draw_bar;
                end
            end

        end
    end
    methods (Access = private)
        function draw_bar(obj)
            back = repmat('\b', [1,obj.square_nums+2+4]);
            fprintf(back);
            fprintf('<');
            if (obj.s_num > 0)
                for i = 1:obj.s_num
                    fprintf(obj.solid_square);
                end
            end
            if (obj.h_num > 0)
                for i = 1:obj.h_num
                    fprintf(obj.hollow_square);
                end
            end
            fprintf('>');
            precent = num2str(round((obj.temp_num/obj.N)*100));
            if length(precent) < 3
                precent = [repmat(' ',[1,3-length(precent)]),precent];
            end
            fprintf([precent,'%%']);
            if obj.temp_num == obj.N
                fprintf('\n');
            end
        end
    end
end
```

## MATLAB中调整绘图colorbar的颜色



## 并行计算parfor的使用

MATLAB并行化计算功能通常使用Parallel Computing Toolbox工具箱实现，当我们使用多核处理器/GPU/计算集群时可以利用该工具箱实现并行计算，以充分利用资源。
在这里仅阐述对于多核CPU的并行化计算功能，并行化计算功能只能对于`for`循环结构使用，且有一定限制。当我们使用多核CPU时，通常的MATLAB程序将只会调度其中一个核，
可以使用`parfor`替换程序中的`for`循环结构来实现并行化。

示例程序如下，两种写法均可以，其中`M`表示给当前`parfor`分配的线程数，若不指定则默认分配当前最大线程数。
```MATLAB
% Example 1
parfor loopvar = initval:endval
    statements;
end
% Example 2
parfor (loopvar = initval:endval, M)
    statements;
end
```

### 使用并行计算parfor指令的前提

首先需要明确一点并不是任何程序使用`parfor`指令都能够带来处理增益，也并不是所有程序都可以使用`parfor`指令。

什么情况下使用`parfor`指令可以给程序带来增益。

1. for循环中的计算量很大

使用`parfor`指令的限制

1. 对于loopvar的要求
在`parfor`中，
2. 对于statements的要求
对于循环中的结构必须是每次独立的，即第i次循环的结果与任意一次其它循环的结果都应无关，其中i为第任意次循环的下标。
3. 